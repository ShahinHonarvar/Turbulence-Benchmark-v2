{"category": "PytestAssertRewriteWarning", "filename": "/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", "lineno": 1204, "message": "Module already imported so cannot be rewritten: anyio", "$report_type": "WarningMessage", "when": "config", "location": ["/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", 1204, "_consider_importhook"]}
{"category": "PytestAssertRewriteWarning", "filename": "/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", "lineno": 1204, "message": "Module already imported so cannot be rewritten: anyio", "$report_type": "WarningMessage", "when": "config", "location": ["/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", 1204, "_consider_importhook"]}
{"pytest_version": "7.4.4", "$report_type": "SessionStart"}
{"nodeid": "tests47_100_4.py::test_string_of_spaces_and_letters", "location": ["tests47_100_4.py", 27, "test_string_of_spaces_and_letters"], "keywords": {"test_string_of_spaces_and_letters": 1, "tests47_100_4.py": 1, "Folder_100": 1}, "outcome": "passed", "longrepr": null, "when": "setup", "user_properties": [], "sections": [], "duration": 0.00018778200001179357, "start": 1729814327.6329587, "stop": 1729814327.6331475, "$report_type": "TestReport", "item_index": 4, "worker_id": "gw1", "testrun_uid": "f066bb27a092418daa6ecb4e9493725d", "node": "<WorkerController gw1>"}
{"nodeid": "tests47_100_4.py::test_string_of_distinct_chars", "location": ["tests47_100_4.py", 17, "test_string_of_distinct_chars"], "keywords": {"test_string_of_distinct_chars": 1, "tests47_100_4.py": 1, "Folder_100": 1}, "outcome": "passed", "longrepr": null, "when": "setup", "user_properties": [], "sections": [], "duration": 0.0001822130002437916, "start": 1729814327.6329365, "stop": 1729814327.6331189, "$report_type": "TestReport", "item_index": 2, "worker_id": "gw2", "testrun_uid": "f066bb27a092418daa6ecb4e9493725d", "node": "<WorkerController gw2>"}
{"nodeid": "tests47_100_4.py::test_string_of_similar_chars", "location": ["tests47_100_4.py", 3, "test_string_of_similar_chars"], "keywords": {"test_string_of_similar_chars": 1, "tests47_100_4.py": 1, "Folder_100": 1}, "outcome": "passed", "longrepr": null, "when": "setup", "user_properties": [], "sections": [], "duration": 0.00030661000027976115, "start": 1729814327.6329117, "stop": 1729814327.6332192, "$report_type": "TestReport", "item_index": 0, "worker_id": "gw0", "testrun_uid": "f066bb27a092418daa6ecb4e9493725d", "node": "<WorkerController gw0>"}
{"nodeid": "tests47_100_4.py::test_string_of_similar_chars", "location": ["tests47_100_4.py", 3, "test_string_of_similar_chars"], "keywords": {"test_string_of_similar_chars": 1, "tests47_100_4.py": 1, "Folder_100": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_similar_chars():", "        n = max(96, 18)", "        m = min(96 - 29 + 1, 18)", "        s = ''.join('a' for _ in range(n * 2))", ">       assert palindromes_of_specific_lengths(s) == {'a' * i for i in range(12, m + 1)}"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q47/codegemma_results_4/Folder_100/tests47_100_4.py", "lineno": 8, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    return set(re.findall(pattern, text))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q47/codegemma_results_4/Folder_100/generated_answer.py", "lineno": 6, "message": "in palindromes_of_specific_lengths"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 12, 18, ASSERT, ...]"], ["pattern", "[(ASSERT, (-1, [(MAX_REPEAT, (29, 96, [(ANY, None)]))])), (SUBPATTERN, (1, 0, 0, [(MAX_REPEAT, (12, 18, [(IN, [(RANGE, (97, 122))])]))])), (ASSERT, (1, [(LITERAL, 92), (LITERAL, 98)]))]"], ["flags", "32"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_similar_chars():", "        n = max(96, 18)", "        m = min(96 - 29 + 1, 18)", "        s = ''.join('a' for _ in range(n * 2))", ">       assert palindromes_of_specific_lengths(s) == {'a' * i for i in range(12, m + 1)}"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q47/codegemma_results_4/Folder_100/tests47_100_4.py", "lineno": 8, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    return set(re.findall(pattern, text))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q47/codegemma_results_4/Folder_100/generated_answer.py", "lineno": 6, "message": "in palindromes_of_specific_lengths"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 12, 18, ASSERT, ...]"], ["pattern", "[(ASSERT, (-1, [(MAX_REPEAT, (29, 96, [(ANY, None)]))])), (SUBPATTERN, (1, 0, 0, [(MAX_REPEAT, (12, 18, [(IN, [(RANGE, (97, 122))])]))])), (ASSERT, (1, [(LITERAL, 92), (LITERAL, 98)]))]"], ["flags", "32"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, null]]}, "when": "call", "user_properties": [], "sections": [], "duration": 0.00037214899975879234, "start": 1729814327.633584, "stop": 1729814327.6339571, "extras": [], "$report_type": "TestReport", "item_index": 0, "worker_id": "gw0", "testrun_uid": "f066bb27a092418daa6ecb4e9493725d", "node": "<WorkerController gw0>"}
{"nodeid": "tests47_100_4.py::test_string_of_similar_chars", "location": ["tests47_100_4.py", 3, "test_string_of_similar_chars"], "keywords": {"test_string_of_similar_chars": 1, "tests47_100_4.py": 1, "Folder_100": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [], "duration": 0.00011786899995058775, "start": 1729814327.6655307, "stop": 1729814327.6656492, "$report_type": "TestReport", "item_index": 0, "worker_id": "gw0", "testrun_uid": "f066bb27a092418daa6ecb4e9493725d", "node": "<WorkerController gw0>"}
{"nodeid": "tests47_100_4.py::test_string_of_distinct_chars", "location": ["tests47_100_4.py", 17, "test_string_of_distinct_chars"], "keywords": {"test_string_of_distinct_chars": 1, "tests47_100_4.py": 1, "Folder_100": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_distinct_chars():", "        s = 'abc' * (96 * 3)", ">       assert not palindromes_of_specific_lengths(s)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q47/codegemma_results_4/Folder_100/tests47_100_4.py", "lineno": 20, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    return set(re.findall(pattern, text))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q47/codegemma_results_4/Folder_100/generated_answer.py", "lineno": 6, "message": "in palindromes_of_specific_lengths"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 12, 18, ASSERT, ...]"], ["pattern", "[(ASSERT, (-1, [(MAX_REPEAT, (29, 96, [(ANY, None)]))])), (SUBPATTERN, (1, 0, 0, [(MAX_REPEAT, (12, 18, [(IN, [(RANGE, (97, 122))])]))])), (ASSERT, (1, [(LITERAL, 92), (LITERAL, 98)]))]"], ["flags", "32"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_distinct_chars():", "        s = 'abc' * (96 * 3)", ">       assert not palindromes_of_specific_lengths(s)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q47/codegemma_results_4/Folder_100/tests47_100_4.py", "lineno": 20, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    return set(re.findall(pattern, text))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q47/codegemma_results_4/Folder_100/generated_answer.py", "lineno": 6, "message": "in palindromes_of_specific_lengths"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 12, 18, ASSERT, ...]"], ["pattern", "[(ASSERT, (-1, [(MAX_REPEAT, (29, 96, [(ANY, None)]))])), (SUBPATTERN, (1, 0, 0, [(MAX_REPEAT, (12, 18, [(IN, [(RANGE, (97, 122))])]))])), (ASSERT, (1, [(LITERAL, 92), (LITERAL, 98)]))]"], ["flags", "32"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, null]]}, "when": "call", "user_properties": [], "sections": [], "duration": 0.00027768900008595665, "start": 1729814327.6333983, "stop": 1729814327.6336765, "extras": [], "$report_type": "TestReport", "item_index": 2, "worker_id": "gw2", "testrun_uid": "f066bb27a092418daa6ecb4e9493725d", "node": "<WorkerController gw2>"}
{"nodeid": "tests47_100_4.py::test_string_of_distinct_chars", "location": ["tests47_100_4.py", 17, "test_string_of_distinct_chars"], "keywords": {"test_string_of_distinct_chars": 1, "tests47_100_4.py": 1, "Folder_100": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [], "duration": 0.000163538999913726, "start": 1729814327.6802413, "stop": 1729814327.6804063, "$report_type": "TestReport", "item_index": 2, "worker_id": "gw2", "testrun_uid": "f066bb27a092418daa6ecb4e9493725d", "node": "<WorkerController gw2>"}
{"nodeid": "tests47_100_4.py::test_string_of_spaces_and_letters", "location": ["tests47_100_4.py", 27, "test_string_of_spaces_and_letters"], "keywords": {"test_string_of_spaces_and_letters": 1, "tests47_100_4.py": 1, "Folder_100": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_spaces_and_letters():", "        s = ' a ' * (96 * 3)", ">       assert not palindromes_of_specific_lengths(s)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q47/codegemma_results_4/Folder_100/tests47_100_4.py", "lineno": 30, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    return set(re.findall(pattern, text))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q47/codegemma_results_4/Folder_100/generated_answer.py", "lineno": 6, "message": "in palindromes_of_specific_lengths"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 12, 18, ASSERT, ...]"], ["pattern", "[(ASSERT, (-1, [(MAX_REPEAT, (29, 96, [(ANY, None)]))])), (SUBPATTERN, (1, 0, 0, [(MAX_REPEAT, (12, 18, [(IN, [(RANGE, (97, 122))])]))])), (ASSERT, (1, [(LITERAL, 92), (LITERAL, 98)]))]"], ["flags", "32"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_spaces_and_letters():", "        s = ' a ' * (96 * 3)", ">       assert not palindromes_of_specific_lengths(s)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q47/codegemma_results_4/Folder_100/tests47_100_4.py", "lineno": 30, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    return set(re.findall(pattern, text))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q47/codegemma_results_4/Folder_100/generated_answer.py", "lineno": 6, "message": "in palindromes_of_specific_lengths"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 12, 18, ASSERT, ...]"], ["pattern", "[(ASSERT, (-1, [(MAX_REPEAT, (29, 96, [(ANY, None)]))])), (SUBPATTERN, (1, 0, 0, [(MAX_REPEAT, (12, 18, [(IN, [(RANGE, (97, 122))])]))])), (ASSERT, (1, [(LITERAL, 92), (LITERAL, 98)]))]"], ["flags", "32"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, null]]}, "when": "call", "user_properties": [], "sections": [], "duration": 0.00030530499998349114, "start": 1729814327.6334534, "stop": 1729814327.6337593, "extras": [], "$report_type": "TestReport", "item_index": 4, "worker_id": "gw1", "testrun_uid": "f066bb27a092418daa6ecb4e9493725d", "node": "<WorkerController gw1>"}
{"nodeid": "tests47_100_4.py::test_string_of_spaces_and_letters", "location": ["tests47_100_4.py", 27, "test_string_of_spaces_and_letters"], "keywords": {"test_string_of_spaces_and_letters": 1, "tests47_100_4.py": 1, "Folder_100": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [], "duration": 0.00018751100014924305, "start": 1729814327.6827073, "stop": 1729814327.6828957, "$report_type": "TestReport", "item_index": 4, "worker_id": "gw1", "testrun_uid": "f066bb27a092418daa6ecb4e9493725d", "node": "<WorkerController gw1>"}
{"exitstatus": 2, "$report_type": "SessionFinish"}
