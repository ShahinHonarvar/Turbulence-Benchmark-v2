{"category": "PytestAssertRewriteWarning", "filename": "/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", "lineno": 1277, "message": "Module already imported so cannot be rewritten: anyio", "$report_type": "WarningMessage", "when": "config", "location": ["/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", 1277, "_consider_importhook"]}
{"category": "PytestAssertRewriteWarning", "filename": "/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", "lineno": 1277, "message": "Module already imported so cannot be rewritten: anyio", "$report_type": "WarningMessage", "when": "config", "location": ["/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", 1277, "_consider_importhook"]}
{"pytest_version": "8.3.3", "$report_type": "SessionStart"}
{"nodeid": "tests53_90_3.py::test_string_of_similar_chars_of_length_140", "location": ["tests53_90_3.py", 5, "test_string_of_similar_chars_of_length_140"], "keywords": {"test_string_of_similar_chars_of_length_140": 1, "tests53_90_3.py": 1, "Folder_90": 1, "": 1}, "outcome": "passed", "longrepr": null, "when": "setup", "user_properties": [], "sections": [], "duration": 9.5355324447155e-05, "start": 1738464248.534769, "stop": 1738464248.5348647, "$report_type": "TestReport", "item_index": 0, "worker_id": "gw0", "testrun_uid": "0a20bedbf48b4e43a2d05392b17a3cbb", "node": "<WorkerController gw0>"}
{"nodeid": "tests53_90_3.py::test_string_of_similar_chars_of_length_140", "location": ["tests53_90_3.py", 5, "test_string_of_similar_chars_of_length_140"], "keywords": {"test_string_of_similar_chars_of_length_140": 1, "tests53_90_3.py": 1, "Folder_90": 1, "": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_similar_chars_of_length_140():", "        s = ''.join('a' for _ in range(140))", ">       assert palindrome_of_length_at_least_n(s) == {s}"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q53/starcoder2_15b_instruct_v0_1_results_3/Folder_90/tests53_90_3.py", "lineno": 8, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    pattern = re.compile('(?<=^.{140,})(.+?)\\\\1(?=.*$)', re.IGNORECASE)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q53/starcoder2_15b_instruct_v0_1_results_3/Folder_90/generated_answer.py", "lineno": 4, "message": "in palindrome_of_length_at_least_n"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 228, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 2, 4294967295, ASSERT, ...]"], ["pattern", "[(ASSERT, (-1, [(AT, AT_BEGINNING), (MAX_REPEAT, (140, MAXREPEAT, [(ANY, None)]))])), (SUBPATTERN, (1, 0, 0, [(MIN_REP...XREPEAT, [(ANY, None)]))])), (GROUPREF, 1), (ASSERT, (1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (AT, AT_END)]))]"], ["flags", "34"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_similar_chars_of_length_140():", "        s = ''.join('a' for _ in range(140))", ">       assert palindrome_of_length_at_least_n(s) == {s}"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q53/starcoder2_15b_instruct_v0_1_results_3/Folder_90/tests53_90_3.py", "lineno": 8, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    pattern = re.compile('(?<=^.{140,})(.+?)\\\\1(?=.*$)', re.IGNORECASE)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q53/starcoder2_15b_instruct_v0_1_results_3/Folder_90/generated_answer.py", "lineno": 4, "message": "in palindrome_of_length_at_least_n"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 228, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 2, 4294967295, ASSERT, ...]"], ["pattern", "[(ASSERT, (-1, [(AT, AT_BEGINNING), (MAX_REPEAT, (140, MAXREPEAT, [(ANY, None)]))])), (SUBPATTERN, (1, 0, 0, [(MIN_REP...XREPEAT, [(ANY, None)]))])), (GROUPREF, 1), (ASSERT, (1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (AT, AT_END)]))]"], ["flags", "34"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, null]]}, "when": "call", "user_properties": [], "sections": [], "duration": 0.0001753140240907669, "start": 1738464248.5349956, "stop": 1738464248.535171, "extras": [], "$report_type": "TestReport", "item_index": 0, "worker_id": "gw0", "testrun_uid": "0a20bedbf48b4e43a2d05392b17a3cbb", "node": "<WorkerController gw0>"}
{"nodeid": "tests53_90_3.py::test_string_of_similar_chars_of_length_140", "location": ["tests53_90_3.py", 5, "test_string_of_similar_chars_of_length_140"], "keywords": {"test_string_of_similar_chars_of_length_140": 1, "tests53_90_3.py": 1, "Folder_90": 1, "": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [], "duration": 0.00010546017438173294, "start": 1738464248.5598578, "stop": 1738464248.559964, "$report_type": "TestReport", "item_index": 0, "worker_id": "gw0", "testrun_uid": "0a20bedbf48b4e43a2d05392b17a3cbb", "node": "<WorkerController gw0>"}
{"exitstatus": 2, "$report_type": "SessionFinish"}
