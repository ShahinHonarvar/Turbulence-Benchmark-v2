{"category": "PytestAssertRewriteWarning", "filename": "/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", "lineno": 1204, "message": "Module already imported so cannot be rewritten: anyio", "$report_type": "WarningMessage", "when": "config", "location": ["/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", 1204, "_consider_importhook"]}
{"category": "PytestAssertRewriteWarning", "filename": "/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", "lineno": 1204, "message": "Module already imported so cannot be rewritten: anyio", "$report_type": "WarningMessage", "when": "config", "location": ["/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", 1204, "_consider_importhook"]}
{"pytest_version": "7.4.4", "$report_type": "SessionStart"}
{"nodeid": "tests35_49_4.py::test_repeat_char", "location": ["tests35_49_4.py", 5, "test_repeat_char"], "keywords": {"test_repeat_char": 1, "tests35_49_4.py": 1, "Folder_49": 1}, "outcome": "passed", "longrepr": null, "when": "setup", "user_properties": [], "sections": [], "duration": 0.0001295160036534071, "start": 1730864249.4601614, "stop": 1730864249.4602914, "$report_type": "TestReport", "item_index": 0, "worker_id": "gw0", "testrun_uid": "a381958953e945e8b4c14830f249d0c6", "node": "<WorkerController gw0>"}
{"nodeid": "tests35_49_4.py::test_absence_of_duplicates", "location": ["tests35_49_4.py", 31, "test_absence_of_duplicates"], "keywords": {"test_absence_of_duplicates": 1, "tests35_49_4.py": 1, "Folder_49": 1}, "outcome": "passed", "longrepr": null, "when": "setup", "user_properties": [], "sections": [], "duration": 0.00011178699787706137, "start": 1730864249.4600394, "stop": 1730864249.4601514, "$report_type": "TestReport", "item_index": 4, "worker_id": "gw2", "testrun_uid": "a381958953e945e8b4c14830f249d0c6", "node": "<WorkerController gw2>"}
{"nodeid": "tests35_49_4.py::test_merged_strings", "location": ["tests35_49_4.py", 18, "test_merged_strings"], "keywords": {"test_merged_strings": 1, "tests35_49_4.py": 1, "Folder_49": 1}, "outcome": "passed", "longrepr": null, "when": "setup", "user_properties": [], "sections": [], "duration": 0.0001544490223750472, "start": 1730864249.4602165, "stop": 1730864249.4603717, "$report_type": "TestReport", "item_index": 2, "worker_id": "gw1", "testrun_uid": "a381958953e945e8b4c14830f249d0c6", "node": "<WorkerController gw1>"}
{"nodeid": "tests35_49_4.py::test_absence_of_duplicates", "location": ["tests35_49_4.py", 31, "test_absence_of_duplicates"], "keywords": {"test_absence_of_duplicates": 1, "tests35_49_4.py": 1, "Folder_49": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_absence_of_duplicates():", "        s = ''.join(random.choice(string.ascii_letters) for _ in range(200*2))", "        sliced_s = s[90 + 1:200]", ">       returned_s = remove_repeat_chars(s)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q35/starcoder2_15b_instruct_v0_1_results_4/Folder_49/tests35_49_4.py", "lineno": 35, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    characters_to_remove = set(re.findall('(.)(?<=90:.+?200:).*\\\\\\\\1', text))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q35/starcoder2_15b_instruct_v0_1_results_4/Folder_49/generated_answer.py", "lineno": 7, "message": "in remove_repeat_chars"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 3, 4294967295, MARK, ...]"], ["pattern", "[(SUBPATTERN, (1, 0, 0, [(ANY, None)])), (ASSERT, (-1, [(LITERAL, 57), (LITERAL, 48), (LITERAL, 58), (MIN_REPEAT, (1, ...TERAL, 48), (LITERAL, 48), (LITERAL, 58)])), (MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (LITERAL, 92), (LITERAL, 49)]"], ["flags", "32"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_absence_of_duplicates():", "        s = ''.join(random.choice(string.ascii_letters) for _ in range(200*2))", "        sliced_s = s[90 + 1:200]", ">       returned_s = remove_repeat_chars(s)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q35/starcoder2_15b_instruct_v0_1_results_4/Folder_49/tests35_49_4.py", "lineno": 35, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    characters_to_remove = set(re.findall('(.)(?<=90:.+?200:).*\\\\\\\\1', text))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q35/starcoder2_15b_instruct_v0_1_results_4/Folder_49/generated_answer.py", "lineno": 7, "message": "in remove_repeat_chars"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 3, 4294967295, MARK, ...]"], ["pattern", "[(SUBPATTERN, (1, 0, 0, [(ANY, None)])), (ASSERT, (-1, [(LITERAL, 57), (LITERAL, 48), (LITERAL, 58), (MIN_REPEAT, (1, ...TERAL, 48), (LITERAL, 48), (LITERAL, 58)])), (MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (LITERAL, 92), (LITERAL, 49)]"], ["flags", "32"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, null]]}, "when": "call", "user_properties": [], "sections": [], "duration": 0.0002451860345900059, "start": 1730864249.4603236, "stop": 1730864249.4605691, "extras": [], "$report_type": "TestReport", "item_index": 4, "worker_id": "gw2", "testrun_uid": "a381958953e945e8b4c14830f249d0c6", "node": "<WorkerController gw2>"}
{"nodeid": "tests35_49_4.py::test_absence_of_duplicates", "location": ["tests35_49_4.py", 31, "test_absence_of_duplicates"], "keywords": {"test_absence_of_duplicates": 1, "tests35_49_4.py": 1, "Folder_49": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [], "duration": 0.00019161298405379057, "start": 1730864249.485658, "stop": 1730864249.4858506, "$report_type": "TestReport", "item_index": 4, "worker_id": "gw2", "testrun_uid": "a381958953e945e8b4c14830f249d0c6", "node": "<WorkerController gw2>"}
{"nodeid": "tests35_49_4.py::test_repeat_char", "location": ["tests35_49_4.py", 5, "test_repeat_char"], "keywords": {"test_repeat_char": 1, "tests35_49_4.py": 1, "Folder_49": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_repeat_char():", "        s = 'a' * (200 + 2)", "        if 200 - 90 - 1 == 1:", "            assert remove_repeat_chars(s) == s", "        else:", ">           assert not remove_repeat_chars(s)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q35/starcoder2_15b_instruct_v0_1_results_4/Folder_49/tests35_49_4.py", "lineno": 11, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    characters_to_remove = set(re.findall('(.)(?<=90:.+?200:).*\\\\\\\\1', text))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q35/starcoder2_15b_instruct_v0_1_results_4/Folder_49/generated_answer.py", "lineno": 7, "message": "in remove_repeat_chars"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 3, 4294967295, MARK, ...]"], ["pattern", "[(SUBPATTERN, (1, 0, 0, [(ANY, None)])), (ASSERT, (-1, [(LITERAL, 57), (LITERAL, 48), (LITERAL, 58), (MIN_REPEAT, (1, ...TERAL, 48), (LITERAL, 48), (LITERAL, 58)])), (MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (LITERAL, 92), (LITERAL, 49)]"], ["flags", "32"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_repeat_char():", "        s = 'a' * (200 + 2)", "        if 200 - 90 - 1 == 1:", "            assert remove_repeat_chars(s) == s", "        else:", ">           assert not remove_repeat_chars(s)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q35/starcoder2_15b_instruct_v0_1_results_4/Folder_49/tests35_49_4.py", "lineno": 11, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    characters_to_remove = set(re.findall('(.)(?<=90:.+?200:).*\\\\\\\\1', text))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q35/starcoder2_15b_instruct_v0_1_results_4/Folder_49/generated_answer.py", "lineno": 7, "message": "in remove_repeat_chars"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 3, 4294967295, MARK, ...]"], ["pattern", "[(SUBPATTERN, (1, 0, 0, [(ANY, None)])), (ASSERT, (-1, [(LITERAL, 57), (LITERAL, 48), (LITERAL, 58), (MIN_REPEAT, (1, ...TERAL, 48), (LITERAL, 48), (LITERAL, 58)])), (MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (LITERAL, 92), (LITERAL, 49)]"], ["flags", "32"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, null]]}, "when": "call", "user_properties": [], "sections": [], "duration": 0.0002134090755134821, "start": 1730864249.4604805, "stop": 1730864249.4606943, "extras": [], "$report_type": "TestReport", "item_index": 0, "worker_id": "gw0", "testrun_uid": "a381958953e945e8b4c14830f249d0c6", "node": "<WorkerController gw0>"}
{"nodeid": "tests35_49_4.py::test_repeat_char", "location": ["tests35_49_4.py", 5, "test_repeat_char"], "keywords": {"test_repeat_char": 1, "tests35_49_4.py": 1, "Folder_49": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [], "duration": 0.00012274598702788353, "start": 1730864249.486785, "stop": 1730864249.4869084, "$report_type": "TestReport", "item_index": 0, "worker_id": "gw0", "testrun_uid": "a381958953e945e8b4c14830f249d0c6", "node": "<WorkerController gw0>"}
{"nodeid": "tests35_49_4.py::test_merged_strings", "location": ["tests35_49_4.py", 18, "test_merged_strings"], "keywords": {"test_merged_strings": 1, "tests35_49_4.py": 1, "Folder_49": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_merged_strings():", "        s = ('a' * (200 + 1)) + ('b' * 200)", "        if 200 - 90 - 1 == 1:", "            assert remove_repeat_chars(s) == s", "        else:", ">           assert remove_repeat_chars(s) == 'b' * 200"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q35/starcoder2_15b_instruct_v0_1_results_4/Folder_49/tests35_49_4.py", "lineno": 24, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    characters_to_remove = set(re.findall('(.)(?<=90:.+?200:).*\\\\\\\\1', text))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q35/starcoder2_15b_instruct_v0_1_results_4/Folder_49/generated_answer.py", "lineno": 7, "message": "in remove_repeat_chars"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 3, 4294967295, MARK, ...]"], ["pattern", "[(SUBPATTERN, (1, 0, 0, [(ANY, None)])), (ASSERT, (-1, [(LITERAL, 57), (LITERAL, 48), (LITERAL, 58), (MIN_REPEAT, (1, ...TERAL, 48), (LITERAL, 48), (LITERAL, 58)])), (MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (LITERAL, 92), (LITERAL, 49)]"], ["flags", "32"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_merged_strings():", "        s = ('a' * (200 + 1)) + ('b' * 200)", "        if 200 - 90 - 1 == 1:", "            assert remove_repeat_chars(s) == s", "        else:", ">           assert remove_repeat_chars(s) == 'b' * 200"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q35/starcoder2_15b_instruct_v0_1_results_4/Folder_49/tests35_49_4.py", "lineno": 24, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    characters_to_remove = set(re.findall('(.)(?<=90:.+?200:).*\\\\\\\\1', text))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q35/starcoder2_15b_instruct_v0_1_results_4/Folder_49/generated_answer.py", "lineno": 7, "message": "in remove_repeat_chars"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 3, 4294967295, MARK, ...]"], ["pattern", "[(SUBPATTERN, (1, 0, 0, [(ANY, None)])), (ASSERT, (-1, [(LITERAL, 57), (LITERAL, 48), (LITERAL, 58), (MIN_REPEAT, (1, ...TERAL, 48), (LITERAL, 48), (LITERAL, 58)])), (MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (LITERAL, 92), (LITERAL, 49)]"], ["flags", "32"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, null]]}, "when": "call", "user_properties": [], "sections": [], "duration": 0.0002551788929849863, "start": 1730864249.4606001, "stop": 1730864249.4608557, "extras": [], "$report_type": "TestReport", "item_index": 2, "worker_id": "gw1", "testrun_uid": "a381958953e945e8b4c14830f249d0c6", "node": "<WorkerController gw1>"}
{"nodeid": "tests35_49_4.py::test_merged_strings", "location": ["tests35_49_4.py", 18, "test_merged_strings"], "keywords": {"test_merged_strings": 1, "tests35_49_4.py": 1, "Folder_49": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [], "duration": 0.00013131299056112766, "start": 1730864249.4867778, "stop": 1730864249.4869096, "$report_type": "TestReport", "item_index": 2, "worker_id": "gw1", "testrun_uid": "a381958953e945e8b4c14830f249d0c6", "node": "<WorkerController gw1>"}
{"exitstatus": 2, "$report_type": "SessionFinish"}
