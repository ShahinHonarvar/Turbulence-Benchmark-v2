{"category": "PytestAssertRewriteWarning", "filename": "/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", "lineno": 1204, "message": "Module already imported so cannot be rewritten: anyio", "$report_type": "WarningMessage", "when": "config", "location": ["/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", 1204, "_consider_importhook"]}
{"category": "PytestAssertRewriteWarning", "filename": "/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", "lineno": 1204, "message": "Module already imported so cannot be rewritten: anyio", "$report_type": "WarningMessage", "when": "config", "location": ["/data/miniconda3/envs/benchmark/lib/python3.12/site-packages/_pytest/config/__init__.py", 1204, "_consider_importhook"]}
{"pytest_version": "7.4.4", "$report_type": "SessionStart"}
{"nodeid": "tests53_60_5.py::test_string_of_spaces_and_letters", "location": ["tests53_60_5.py", 32, "test_string_of_spaces_and_letters"], "keywords": {"test_string_of_spaces_and_letters": 1, "tests53_60_5.py": 1, "Folder_60": 1}, "outcome": "passed", "longrepr": null, "when": "setup", "user_properties": [], "sections": [], "duration": 0.00010394700802862644, "start": 1731138264.858125, "stop": 1731138264.8582294, "$report_type": "TestReport", "item_index": 4, "worker_id": "gw2", "testrun_uid": "822db44c8cd645738d4f4888bf74b978", "node": "<WorkerController gw2>"}
{"nodeid": "tests53_60_5.py::test_string_of_many_chars", "location": ["tests53_60_5.py", 19, "test_string_of_many_chars"], "keywords": {"test_string_of_many_chars": 1, "tests53_60_5.py": 1, "Folder_60": 1}, "outcome": "passed", "longrepr": null, "when": "setup", "user_properties": [], "sections": [], "duration": 0.00013960502110421658, "start": 1731138264.8582716, "stop": 1731138264.8584116, "$report_type": "TestReport", "item_index": 2, "worker_id": "gw1", "testrun_uid": "822db44c8cd645738d4f4888bf74b978", "node": "<WorkerController gw1>"}
{"nodeid": "tests53_60_5.py::test_string_of_similar_chars_of_length_80", "location": ["tests53_60_5.py", 5, "test_string_of_similar_chars_of_length_80"], "keywords": {"test_string_of_similar_chars_of_length_80": 1, "tests53_60_5.py": 1, "Folder_60": 1}, "outcome": "passed", "longrepr": null, "when": "setup", "user_properties": [], "sections": [], "duration": 0.00016554002650082111, "start": 1731138264.8583555, "stop": 1731138264.8585217, "$report_type": "TestReport", "item_index": 0, "worker_id": "gw0", "testrun_uid": "822db44c8cd645738d4f4888bf74b978", "node": "<WorkerController gw0>"}
{"nodeid": "tests53_60_5.py::test_string_of_spaces_and_letters", "location": ["tests53_60_5.py", 32, "test_string_of_spaces_and_letters"], "keywords": {"test_string_of_spaces_and_letters": 1, "tests53_60_5.py": 1, "Folder_60": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_spaces_and_letters():", "        s = ' a ' * 80 * 2", "        ss = s.replace(' ','')", "        sss = ss[:80]", "        result = []", "        for i in range(0, 80 + 1):", "            result.append(sss + ('a' * i))", ">       assert not palindrome_of_length_at_least_n(s)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q53/command_results_5/Folder_60/tests53_60_5.py", "lineno": 40, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    return set(re.findall('(?i)(?=.*[a-z]).*(?<=.*[a-z])', s))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q53/command_results_5/Folder_60/generated_answer.py", "lineno": 4, "message": "in palindrome_of_length_at_least_n"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 0, 4294967295, ASSERT, ...]"], ["pattern", "[(ASSERT, (1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (IN, [(RANGE, (97, 122))])])), (MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (ASSERT, (-1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (IN, [(RANGE, (97, 122))])]))]"], ["flags", "34"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_spaces_and_letters():", "        s = ' a ' * 80 * 2", "        ss = s.replace(' ','')", "        sss = ss[:80]", "        result = []", "        for i in range(0, 80 + 1):", "            result.append(sss + ('a' * i))", ">       assert not palindrome_of_length_at_least_n(s)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q53/command_results_5/Folder_60/tests53_60_5.py", "lineno": 40, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    return set(re.findall('(?i)(?=.*[a-z]).*(?<=.*[a-z])', s))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q53/command_results_5/Folder_60/generated_answer.py", "lineno": 4, "message": "in palindrome_of_length_at_least_n"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 0, 4294967295, ASSERT, ...]"], ["pattern", "[(ASSERT, (1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (IN, [(RANGE, (97, 122))])])), (MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (ASSERT, (-1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (IN, [(RANGE, (97, 122))])]))]"], ["flags", "34"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, null]]}, "when": "call", "user_properties": [], "sections": [], "duration": 0.00030282395891845226, "start": 1731138264.8584023, "stop": 1731138264.8587055, "extras": [], "$report_type": "TestReport", "item_index": 4, "worker_id": "gw2", "testrun_uid": "822db44c8cd645738d4f4888bf74b978", "node": "<WorkerController gw2>"}
{"nodeid": "tests53_60_5.py::test_string_of_spaces_and_letters", "location": ["tests53_60_5.py", 32, "test_string_of_spaces_and_letters"], "keywords": {"test_string_of_spaces_and_letters": 1, "tests53_60_5.py": 1, "Folder_60": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [], "duration": 0.00011934898793697357, "start": 1731138264.883372, "stop": 1731138264.8834925, "$report_type": "TestReport", "item_index": 4, "worker_id": "gw2", "testrun_uid": "822db44c8cd645738d4f4888bf74b978", "node": "<WorkerController gw2>"}
{"nodeid": "tests53_60_5.py::test_string_of_many_chars", "location": ["tests53_60_5.py", 19, "test_string_of_many_chars"], "keywords": {"test_string_of_many_chars": 1, "tests53_60_5.py": 1, "Folder_60": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_many_chars():", "        s = 'abcdef'", "        r = ''", "        for _ in range(80):", "            r += s", ">       assert not palindrome_of_length_at_least_n(r)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q53/command_results_5/Folder_60/tests53_60_5.py", "lineno": 25, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    return set(re.findall('(?i)(?=.*[a-z]).*(?<=.*[a-z])', s))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q53/command_results_5/Folder_60/generated_answer.py", "lineno": 4, "message": "in palindrome_of_length_at_least_n"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 0, 4294967295, ASSERT, ...]"], ["pattern", "[(ASSERT, (1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (IN, [(RANGE, (97, 122))])])), (MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (ASSERT, (-1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (IN, [(RANGE, (97, 122))])]))]"], ["flags", "34"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_many_chars():", "        s = 'abcdef'", "        r = ''", "        for _ in range(80):", "            r += s", ">       assert not palindrome_of_length_at_least_n(r)"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q53/command_results_5/Folder_60/tests53_60_5.py", "lineno": 25, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    return set(re.findall('(?i)(?=.*[a-z]).*(?<=.*[a-z])', s))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q53/command_results_5/Folder_60/generated_answer.py", "lineno": 4, "message": "in palindrome_of_length_at_least_n"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 0, 4294967295, ASSERT, ...]"], ["pattern", "[(ASSERT, (1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (IN, [(RANGE, (97, 122))])])), (MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (ASSERT, (-1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (IN, [(RANGE, (97, 122))])]))]"], ["flags", "34"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, null]]}, "when": "call", "user_properties": [], "sections": [], "duration": 0.00041215296369045973, "start": 1731138264.8586502, "stop": 1731138264.8590627, "extras": [], "$report_type": "TestReport", "item_index": 2, "worker_id": "gw1", "testrun_uid": "822db44c8cd645738d4f4888bf74b978", "node": "<WorkerController gw1>"}
{"nodeid": "tests53_60_5.py::test_string_of_many_chars", "location": ["tests53_60_5.py", 19, "test_string_of_many_chars"], "keywords": {"test_string_of_many_chars": 1, "tests53_60_5.py": 1, "Folder_60": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [], "duration": 0.00011266604997217655, "start": 1731138264.8891914, "stop": 1731138264.8893049, "$report_type": "TestReport", "item_index": 2, "worker_id": "gw1", "testrun_uid": "822db44c8cd645738d4f4888bf74b978", "node": "<WorkerController gw1>"}
{"nodeid": "tests53_60_5.py::test_string_of_similar_chars_of_length_80", "location": ["tests53_60_5.py", 5, "test_string_of_similar_chars_of_length_80"], "keywords": {"test_string_of_similar_chars_of_length_80": 1, "tests53_60_5.py": 1, "Folder_60": 1}, "outcome": "failed", "longrepr": {"reprcrash": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, "reprtraceback": {"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_similar_chars_of_length_80():", "        s = ''.join('a' for _ in range(80))", ">       assert palindrome_of_length_at_least_n(s) == {s}"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q53/command_results_5/Folder_60/tests53_60_5.py", "lineno": 8, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    return set(re.findall('(?i)(?=.*[a-z]).*(?<=.*[a-z])', s))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q53/command_results_5/Folder_60/generated_answer.py", "lineno": 4, "message": "in palindrome_of_length_at_least_n"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 0, 4294967295, ASSERT, ...]"], ["pattern", "[(ASSERT, (1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (IN, [(RANGE, (97, 122))])])), (MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (ASSERT, (-1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (IN, [(RANGE, (97, 122))])]))]"], ["flags", "34"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, "sections": [], "chain": [[{"reprentries": [{"type": "ReprEntry", "data": {"lines": ["    def test_string_of_similar_chars_of_length_80():", "        s = ''.join('a' for _ in range(80))", ">       assert palindrome_of_length_at_least_n(s) == {s}"], "reprfuncargs": {"args": []}, "reprlocals": null, "reprfileloc": {"path": "Q53/command_results_5/Folder_60/tests53_60_5.py", "lineno": 8, "message": ""}, "style": "long"}}, {"type": "ReprEntry", "data": {"lines": ["    return set(re.findall('(?i)(?=.*[a-z]).*(?<=.*[a-z])', s))"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "Q53/command_results_5/Folder_60/generated_answer.py", "lineno": 4, "message": "in palindrome_of_length_at_least_n"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    return _compile(pattern, flags).findall(string)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 217, "message": "in findall"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    p = _compiler.compile(pattern, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/__init__.py", "lineno": 307, "message": "in _compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    code = _code(p, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 749, "message": "in compile"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    _compile(code, p.data, flags)"], "reprfuncargs": null, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 582, "message": "in _code"}, "style": "short"}}, {"type": "ReprEntry", "data": {"lines": ["    def _compile(code, pattern, flags):", "        # internal: compile a (sub)pattern", "        emit = code.append", "        _len = len", "        LITERAL_CODES = _LITERAL_CODES", "        REPEATING_CODES = _REPEATING_CODES", "        SUCCESS_CODES = _SUCCESS_CODES", "        ASSERT_CODES = _ASSERT_CODES", "        iscased = None", "        tolower = None", "        fixes = None", "        if flags & SRE_FLAG_IGNORECASE and not flags & SRE_FLAG_LOCALE:", "            if flags & SRE_FLAG_UNICODE:", "                iscased = _sre.unicode_iscased", "                tolower = _sre.unicode_tolower", "                fixes = _EXTRA_CASES", "            else:", "                iscased = _sre.ascii_iscased", "                tolower = _sre.ascii_tolower", "        for op, av in pattern:", "            if op in LITERAL_CODES:", "                if not flags & SRE_FLAG_IGNORECASE:", "                    emit(op)", "                    emit(av)", "                elif flags & SRE_FLAG_LOCALE:", "                    emit(OP_LOCALE_IGNORE[op])", "                    emit(av)", "                elif not iscased(av):", "                    emit(op)", "                    emit(av)", "                else:", "                    lo = tolower(av)", "                    if not fixes:  # ascii", "                        emit(OP_IGNORE[op])", "                        emit(lo)", "                    elif lo not in fixes:", "                        emit(OP_UNICODE_IGNORE[op])", "                        emit(lo)", "                    else:", "                        emit(IN_UNI_IGNORE)", "                        skip = _len(code); emit(0)", "                        if op is NOT_LITERAL:", "                            emit(NEGATE)", "                        for k in (lo,) + fixes[lo]:", "                            emit(LITERAL)", "                            emit(k)", "                        emit(FAILURE)", "                        code[skip] = _len(code) - skip", "            elif op is IN:", "                charset, hascased = _optimize_charset(av, iscased, tolower, fixes)", "                if flags & SRE_FLAG_IGNORECASE and flags & SRE_FLAG_LOCALE:", "                    emit(IN_LOC_IGNORE)", "                elif not hascased:", "                    emit(IN)", "                elif not fixes:  # ascii", "                    emit(IN_IGNORE)", "                else:", "                    emit(IN_UNI_IGNORE)", "                skip = _len(code); emit(0)", "                _compile_charset(charset, flags, code)", "                code[skip] = _len(code) - skip", "            elif op is ANY:", "                if flags & SRE_FLAG_DOTALL:", "                    emit(ANY_ALL)", "                else:", "                    emit(ANY)", "            elif op in REPEATING_CODES:", "                if flags & SRE_FLAG_TEMPLATE:", "                    raise error(\"internal: unsupported template operator %r\" % (op,))", "                if _simple(av[2]):", "                    emit(REPEATING_CODES[op][2])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    emit(SUCCESS)", "                    code[skip] = _len(code) - skip", "                else:", "                    emit(REPEATING_CODES[op][0])", "                    skip = _len(code); emit(0)", "                    emit(av[0])", "                    emit(av[1])", "                    _compile(code, av[2], flags)", "                    code[skip] = _len(code) - skip", "                    emit(REPEATING_CODES[op][1])", "            elif op is SUBPATTERN:", "                group, add_flags, del_flags, p = av", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2)", "                # _compile_info(code, p, _combine_flags(flags, add_flags, del_flags))", "                _compile(code, p, _combine_flags(flags, add_flags, del_flags))", "                if group:", "                    emit(MARK)", "                    emit((group-1)*2+1)", "            elif op is ATOMIC_GROUP:", "                # Atomic Groups are handled by starting with an Atomic", "                # Group op code, then putting in the atomic group pattern", "                # and finally a success op code to tell any repeat", "                # operations within the Atomic Group to stop eating and", "                # pop their stack if they reach it", "                emit(ATOMIC_GROUP)", "                skip = _len(code); emit(0)", "                _compile(code, av, flags)", "                emit(SUCCESS)", "                code[skip] = _len(code) - skip", "            elif op in SUCCESS_CODES:", "                emit(op)", "            elif op in ASSERT_CODES:", "                emit(op)", "                skip = _len(code); emit(0)", "                if av[0] >= 0:", "                    emit(0) # look ahead", "                else:", "                    lo, hi = av[1].getwidth()", "                    if lo > MAXCODE:", "                        raise error(\"looks too much behind\")", "                    if lo != hi:", ">                       raise error(\"look-behind requires fixed-width pattern\")", "E                       re.error: look-behind requires fixed-width pattern"], "reprfuncargs": {"args": [["code", "[INFO, 4, 0, 0, 4294967295, ASSERT, ...]"], ["pattern", "[(ASSERT, (1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (IN, [(RANGE, (97, 122))])])), (MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (ASSERT, (-1, [(MAX_REPEAT, (0, MAXREPEAT, [(ANY, None)])), (IN, [(RANGE, (97, 122))])]))]"], ["flags", "34"]]}, "reprlocals": null, "reprfileloc": {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "error"}, "style": "long"}}], "extraline": null, "style": "long"}, {"path": "/data/miniconda3/envs/benchmark/lib/python3.12/re/_compiler.py", "lineno": 155, "message": "re.error: look-behind requires fixed-width pattern"}, null]]}, "when": "call", "user_properties": [], "sections": [], "duration": 0.0004665669985115528, "start": 1731138264.8587751, "stop": 1731138264.859242, "extras": [], "$report_type": "TestReport", "item_index": 0, "worker_id": "gw0", "testrun_uid": "822db44c8cd645738d4f4888bf74b978", "node": "<WorkerController gw0>"}
{"nodeid": "tests53_60_5.py::test_string_of_similar_chars_of_length_80", "location": ["tests53_60_5.py", 5, "test_string_of_similar_chars_of_length_80"], "keywords": {"test_string_of_similar_chars_of_length_80": 1, "tests53_60_5.py": 1, "Folder_60": 1}, "outcome": "passed", "longrepr": null, "when": "teardown", "user_properties": [], "sections": [], "duration": 0.00011183100286871195, "start": 1731138264.8958364, "stop": 1731138264.8959491, "$report_type": "TestReport", "item_index": 0, "worker_id": "gw0", "testrun_uid": "822db44c8cd645738d4f4888bf74b978", "node": "<WorkerController gw0>"}
{"exitstatus": 2, "$report_type": "SessionFinish"}
